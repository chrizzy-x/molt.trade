"""
Wallet Manager - Handles wallet creation and connection for Solana & Base
"""

import base58
import json
from typing import Dict, Optional, Tuple
from solders.keypair import Keypair
from solana.rpc.api import Client
from solana.publickey import PublicKey
from web3 import Web3
from eth_account import Account
from eth_account.signers.local import LocalAccount
import logging

logger = logging.getLogger(__name__)

class WalletManager:
    """Manages wallet operations for Solana and Base (EVM) chains"""
    
    def __init__(self):
        # RPC Endpoints
        self.solana_rpc = "https://api.mainnet-beta.solana.com"
        self.base_rpc = "https://mainnet.base.org"
        
        # Clients
        self.solana_client = Client(self.solana_rpc)
        self.base_web3 = Web3(Web3.HTTPProvider(self.base_rpc))
        
        self.current_keypair = None
        self.current_account = None
        self.chain = None
    
    def create_wallet(self, chain: str) -> Dict:
        """
        Create a new wallet on specified chain
        
        Args:
            chain: "Solana" or "Base"
        
        Returns:
            Dict with public_key and encrypted_private_key
        """
        try:
            if chain == "Solana":
                return self._create_solana_wallet()
            elif chain == "Base":
                return self._create_base_wallet()
            else:
                raise ValueError(f"Unsupported chain: {chain}")
        except Exception as e:
            logger.error(f"Wallet creation error: {str(e)}")
            raise
    
    def _create_solana_wallet(self) -> Dict:
        """Create new Solana keypair"""
        try:
            keypair = Keypair()
            
            # Serialize keypair to secret key format
            secret_bytes = bytes(keypair.secret_key)
            private_key_b58 = base58.b58encode(secret_bytes).decode('utf-8')
            
            return {
                "chain": "Solana",
                "public_key": str(keypair.pubkey()),
                "private_key": private_key_b58,
                "secret_key": list(secret_bytes),  # For JSON serialization
                "created_at": str(__import__('datetime').datetime.now())
            }
        except Exception as e:
            logger.error(f"Solana wallet creation failed: {str(e)}")
            raise
    
    def _create_base_wallet(self) -> Dict:
        """Create new Base (EVM) account"""
        try:
            account: LocalAccount = Account.create()
            
            return {
                "chain": "Base",
                "public_key": account.address,
                "private_key": account.key.hex(),
                "created_at": str(__import__('datetime').datetime.now())
            }
        except Exception as e:
            logger.error(f"Base wallet creation failed: {str(e)}")
            raise
    
    def connect_wallet(
        self,
        chain: str,
        private_key: Optional[str] = None,
        keypair_data: Optional[Dict] = None
    ) -> Dict:
        """
        Connect existing wallet via private key or keypair data
        
        Args:
            chain: "Solana" or "Base"
            private_key: Base58 (Solana) or Hex (Base) private key
            keypair_data: Full keypair JSON dict
        
        Returns:
            Dict with connection info and public key
        """
        try:
            if chain == "Solana":
                return self._connect_solana_wallet(private_key, keypair_data)
            elif chain == "Base":
                return self._connect_base_wallet(private_key, keypair_data)
            else:
                raise ValueError(f"Unsupported chain: {chain}")
        except Exception as e:
            logger.error(f"Wallet connection error: {str(e)}")
            raise
    
    def _connect_solana_wallet(
        self,
        private_key: Optional[str] = None,
        keypair_data: Optional[Dict] = None
    ) -> Dict:
        """Connect Solana wallet"""
        try:
            if keypair_data:
                # Load from keypair JSON (contains secret_key array)
                if "secret_key" in keypair_data:
                    secret_bytes = bytes(keypair_data["secret_key"])
                elif "private_key" in keypair_data:
                    secret_bytes = base58.b58decode(keypair_data["private_key"])
                else:
                    raise ValueError("Invalid keypair format")
            else:
                # Load from Base58 private key
                secret_bytes = base58.b58decode(private_key)
            
            keypair = Keypair.from_secret_key(secret_bytes)
            self.current_keypair = keypair
            self.chain = "Solana"
            
            return {
                "chain": "Solana",
                "public_key": str(keypair.pubkey()),
                "connected": True
            }
        except Exception as e:
            logger.error(f"Solana connection failed: {str(e)}")
            raise ValueError(f"Failed to connect Solana wallet: {str(e)}")
    
    def _connect_base_wallet(
        self,
        private_key: Optional[str] = None,
        keypair_data: Optional[Dict] = None
    ) -> Dict:
        """Connect Base (EVM) wallet"""
        try:
            if keypair_data:
                private_key = keypair_data.get("private_key")
            
            # Ensure hex format
            if not private_key.startswith("0x"):
                private_key = "0x" + private_key
            
            account = Account.from_key(private_key)
            self.current_account = account
            self.chain = "Base"
            
            return {
                "chain": "Base",
                "public_key": account.address,
                "connected": True
            }
        except Exception as e:
            logger.error(f"Base connection failed: {str(e)}")
            raise ValueError(f"Failed to connect Base wallet: {str(e)}")
    
    def get_balance(self, chain: str, public_key: str) -> float:
        """
        Get wallet balance in native token
        
        Args:
            chain: "Solana" or "Base"
            public_key: Wallet public key/address
        
        Returns:
            Balance as float
        """
        try:
            if chain == "Solana":
                return self._get_solana_balance(public_key)
            elif chain == "Base":
                return self._get_base_balance(public_key)
            else:
                raise ValueError(f"Unsupported chain: {chain}")
        except Exception as e:
            logger.error(f"Balance fetch error: {str(e)}")
            raise
    
    def _get_solana_balance(self, public_key: str) -> float:
        """Get Solana account balance in SOL"""
        try:
            pubkey = PublicKey(public_key)
            response = self.solana_client.get_balance(pubkey)
            lamports = response["result"]["value"]
            sol = lamports / 1e9  # 1 SOL = 1e9 lamports
            return sol
        except Exception as e:
            logger.error(f"Solana balance error: {str(e)}")
            raise
    
    def _get_base_balance(self, address: str) -> float:
        """Get Base account balance in ETH"""
        try:
            wei = self.base_web3.eth.get_balance(address)
            eth = self.base_web3.from_wei(wei, 'ether')
            return float(eth)
        except Exception as e:
            logger.error(f"Base balance error: {str(e)}")
            raise
    
    def get_current_keypair(self):
        """Return current Solana keypair"""
        if not self.current_keypair:
            raise ValueError("No Solana wallet connected")
        return self.current_keypair
    
    def get_current_account(self):
        """Return current Base account"""
        if not self.current_account:
            raise ValueError("No Base wallet connected")
        return self.current_account
    
    def switch_chain(self, chain: str):
        """Switch active chain"""
        self.chain = chain
    
    def get_rpc_endpoint(self, chain: str) -> str:
        """Get RPC endpoint for chain"""
        if chain == "Solana":
            return self.solana_rpc
        elif chain == "Base":
            return self.base_rpc
        else:
            raise ValueError(f"Unknown chain: {chain}")


if __name__ == "__main__":
    # Test
    manager = WalletManager()
    
    # Create Solana wallet
    print("Creating Solana wallet...")
    sol_wallet = manager.create_wallet("Solana")
    print(f"Solana Address: {sol_wallet['public_key']}")
    
    # Create Base wallet
    print("\nCreating Base wallet...")
    base_wallet = manager.create_wallet("Base")
    print(f"Base Address: {base_wallet['public_key']}")
